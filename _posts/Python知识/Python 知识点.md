[TOC]

### 语言特性

1.  谈谈对 Python 和其他语言的区别

   Python 是一门语法简洁优美,功能强大无比,应用领域非常广泛,具有强大完备的第三方库，他是一门弱类型的**可移植、可扩展，可嵌入**的解释型编程语言。

   与 C 比较：

   |      | C 语言     | Python               |
   | ---- | ---------- | -------------------- |
   | 优点 | 运行时间快 | 三方库齐全、代码简洁 |
   | 缺点 |            | 运行速度慢           |

2.  简述解释型和编译型编程语言

   解释型语言是在运行程序的时候才翻译，每执行一次，要翻译一次，效率较低。 编译型就是直接编译成机型可以执行的，只翻译一次，所以效率相对来说较高。

3. Python 的解释器种类以及相关特点？

   | CPython    | c 语言开发的，使用最广的解释器                               |
   | ---------- | ------------------------------------------------------------ |
   | IPython    | 基于 cpython 之上的一个交互式计时器，交互方式增强功能和 cpython 一样 |
   | PyPy       | 目标是执行效率，采用 JIT 技术。对 python 代码进行动态编译，提高执行效率 |
   | JPython    | 运行在 Java 上的解释器，直接把 python 代码编译成 Java 字节码执行 |
   | IronPython | 运行在微软 .NET 平台上的解释器，把 python 编译成 . NET 的字节码 |




### 数据类型 - 列表

30. 对列表进行去重

```python
li = [1, 2, 2, 3, 4]
print(list(set(li)))
# [1, 2, 3, 4]
```

31. ####  如何实现 "1,2,3" 变成 ["1","2","3"]

```python
s = "1,2,3"
print(s.split(","))
# ['1', '2', '3']
```

32. #### 给定两个 list，A 和 B，找出相同元素和不同元素（思路：集合可以进行逻辑运算）

```python
A = [1, 2, 3]
B = [1, 2, 3, 4]
print(set(A)&set(B)) # {1, 2, 3}
print(set(A)^set(B)) # {4}
```

33. #### [[1,2],[3,4],[5,6]] 一行代码展开该列表，得出 [1,2,3,4,5,6]

```python
a = [[1,2],[3,4],[5,6]]
[a2 for a1 in a for a2 in a1]
# [1, 2, 3, 4, 5, 6]
```

34. ####  合并列表 [1,5,7,9] 和 [2,2,6,8]

```python
a = [1,5,7,9] 
b = [2,2,6,8]
# a + b
a.extend(b)
print(a) 
```

35. 打乱列表的元素

```python
import random
a = [1, 2, 3, 4, 5]
random.shuffle(a)
print(a)
```



### 并发

 159. 

 160. 说一说多线程，多进程和协程的区别。

      - 进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,
        进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。（开多个软件）
      - 线程：线程是进程的一个实体,是 CPU 调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。（一个软件上面的不同功能）
      - 协程：协程是一种用户态的**轻量级线程**，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
      - 区别： 进程与线程比较： 线程是指进程内的一个执行单元,也是进程内的可调度实体。
      - 线程与进程的区别：
        - 地址空间：线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间
        - 资源拥有：进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源
        - 线程是处理器调度的基本单位,但进程不是
        -  二者均可并发执行
        - 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，
          但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制
      - 协程与线程进行比较：
        - 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样 Python 中则能使用多核 CPU。
        - 线程进程都是同步机制，而协程则是异步
        -  协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态
      - **多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。**

      161. 简述 GIL

           **GIL：全局解释器锁。**每个线程在执行的过程都需要先获取 GIL，保证同一时刻只有一个线程可以执行代码。

           线程释放 GIL 锁的情况：在 IO 操作等可能会引起阻塞的 systemcall 之前,可以暂时释放 GIL，但在执行完毕后, 必须重新获取 GIL，Python3.x 使用计时器（执行时间达到阈值后，当前线程释放 GIL）或 Python2.x，tickets 计数达到 100 。

           Python 使用多进程是可以利用多核的 CPU 资源的。

           多线程爬取比单线程性能有提升，因为遇到 IO 阻塞会自动释放 GIL 锁。

      162.  进程之间如何通信

           通常，使用进程间通信的两个应用可以被分为客户端和服务器（见[主从式架构](https://zh.wikipedia.org/wiki/主從式架構)），客户端进程请求数据，服务端响应客户端的数据请求。有一些应用本身既是服务器又是客户端，这在[分布式计算](https://zh.wikipedia.org/wiki/分布式计算)中，时常可以见到。这些进程可以运行在同一计算机上或网络连接的不同计算机上。

           可以通过队列的形式[消息队列]([https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97](https://zh.wikipedia.org/wiki/消息队列))

           ```python
           from multiprocessing import Queue, Process
           import time, random
           
           # 要写入的数据
           list1 = ["java", "Python", "JavaScript"]
           
           
           def write(queue):
               """
               向队列中添加数据
               ：param queue：
               ：return：
               """
               for value in list1:
                   print(f"正在向队列中添加数据-->{value}")
                   # put_nowait 不会等待队列有空闲位置再放入数据，如果数据放入不成功就直接崩溃,比如数据满了。put 的话就会一直等待
                   queue.put_nowait(value)
                   time.sleep(random.random())
           
           
           def read(queue):
               while True:
                   # 判断队列是否为空
                   if not queue.empty():
                       # get_nowait 队列为空，取值的时候不等待，但是取不到值那么直接崩溃了
                       value = queue.get_nowait()
                       print(f'从队列中取到的数据为-->{value}')
                       time.sleep(random.random())
                   else:
                       break
           
           if __name__ == '__main__':
               # 父进程创建出队列，通过参数的形式传递给子进程
               #queue = Queue(2)
               queue = Queue()
           
               # 创建两个进程 一个写数据 一个读数据
               write_data = Process(target=write, args=(queue,))
               read_data = Process(target=read, args=(queue,))
           
               # 启动进程 写入数据
               write_data.start()
               # 使用 join 等待写数据结束
               write_data.join()
               # 启动进程  读取数据
               print('*' * 20)
               read_data.start()
               # 使用 join  等待读数据结束
               read_data.join()
           
               print('所有的数据都写入并读取完成。。。')
               
           '''
           正在向队列中添加数据-->java
           正在向队列中添加数据-->Python
           正在向队列中添加数据-->JavaScript
           ********************
           从队列中取到的数据为-->java
           从队列中取到的数据为-->Python
           从队列中取到的数据为-->JavaScript
           所有的数据都写入并读取完成。。。
           '''
           ```

      163.  

      164.  

      165.  

      166. 一个线程 1 让线程 2 去调用一个函数怎么实现

           ```python
           import threading
           
           
           def func1(t2):
               print('正在执行函数func1')
               t2.start()
           
           
           def func2():
               print('正在执行函数func2')
           
           
           if __name__ == '__main__':
               t2 = threading.Thread(target=func2) # 开启两个线程
               t1 = threading.Thread(target=func1, args=(t2,))
               t1.start()
               
               
           '''
           正在执行函数func1
           正在执行函数func2
           '''
           ```

           

      167. 